const dotenv = require('dotenv');
const { MongoClient } = require('mongodb');
const fs = require('fs');
const path = require('path');

dotenv.config();

const uri = process.env.MONGODB_URI;
const dbName = process.env.MONGODB_DB_NAME;

if (!uri || !dbName) {
  throw new Error('Missing MONGODB_URI or MONGODB_DB_NAME');
}

// Stores still use seeded locations to provide a framework for the data
const STORES = [
  { name: 'Provigo Le James', address: '3421 Av. du Parc', coords: [-73.5735, 45.5095], type: 'Full Grocery' },
  { name: 'Metro McGill', address: '3575 Park Ave', coords: [-73.5752, 45.5101], type: 'Full Grocery' },
  { name: 'Marché Eden', address: '3575 Ave du Parc #4115', coords: [-73.5756, 45.5052], type: 'Specialty/Asian' },
  { name: 'Marché Newon', address: '1616 Saint-Catherine St W', coords: [-73.5798, 45.5056], type: 'Asian Market' },
  { name: 'Supermarché PA du Parc', address: '5242 Park Ave', coords: [-73.5971, 45.5215], type: 'Discount/Quality' },
  { name: 'Segal’s Market', address: '4001 St Laurent Blvd', coords: [-73.5828, 45.5186], type: 'Budget/Organic' },
  { name: 'Marche G&D', address: '1006 Boul. Saint-Laurent', coords: [-73.5605, 45.5075], type: 'Asian Grocery' },
  { name: 'IGA Van Horne', address: '1250 Av. Van Horne', coords: [-73.6115, 45.5245], type: 'Full Grocery' },
  { name: 'Adonis Downtown', address: '2173 Saint-Catherine St W', coords: [-73.5835, 45.4901], type: 'Middle Eastern' },
  { name: 'Marché Lobo', address: '3509 Av. du Parc', coords: [-73.5742, 45.5112], type: 'Middle Eastern/Convenience' },
];

async function seed() {
  const client = new MongoClient(uri);
  await client.connect();
  const db = client.db(dbName);
  const now = new Date();

  // 1. Load the JSONL data generated by the notebook
  const dataPath = path.join(__dirname, '../../../cleaned_grocery_data.json');
  const externalData = fs
    .readFileSync(dataPath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(Boolean)
    .map(line => JSON.parse(line));

  // 2. Seed Stores
  const storeDocs = STORES.map(store => ({
    name: store.name,
    seededTag: 'seeded',
    location: {
      address: store.address,
      city: 'Montreal',
      state: 'QC',
      zipCode: 'H3A',
      coordinates: { type: 'Point', coordinates: store.coords },
    },
    createdAt: now,
    updatedAt: now,
  }));

  await db.collection('groceryStores').deleteMany({ seededTag: 'seeded' });
  const storeResult = await db.collection('groceryStores').insertMany(storeDocs);
  const storeIds = Object.values(storeResult.insertedIds);

  // 3. Seed Items from JSON (Removing hardcoded templates)
  // Inside the itemDocs mapping in seed-db.js
  const itemDocs = externalData.map(item => ({
    name: item.product_name,
    category: item.aisle || 'Other',
    ...(item.brand ? { brand: item.brand } : {}),
    ...(item.upc ? { barcode: String(item.upc) } : {}), // Ensure upc is a string if it exists
    ...(item.units ? { packageUnit: item.units } : {}),
    ...(item.detail_url ? { itemUrl: item.detail_url } : {}),
    tags: ['seeded', 'real-data'],
    createdAt: now,
    updatedAt: now,
  }));

  // Remove duplicates and insert
  const uniqueItems = Array.from(new Map(itemDocs.map(item => [item.name, item])).values());
  await db.collection('items').deleteMany({ tags: 'seeded' });
  const itemResult = await db.collection('items').insertMany(uniqueItems);

  const itemIdByName = new Map();
  uniqueItems.forEach((item, index) => {
    itemIdByName.set(item.name, itemResult.insertedIds[index]);
  });

  const inventoryDocs = externalData.map(extItem => {
    const itemId = itemIdByName.get(extItem.product_name);
    const storeIndex = STORES.findIndex(s => s.name.toLowerCase().includes(extItem.vendor.toLowerCase()));
    const storeId = storeIndex !== -1 ? storeIds[storeIndex] : storeIds[0];

    // Defensive check for price values that might be null or missing
    const currentPrice = extItem.current_price ? parseFloat(extItem.current_price) : 0;
    const oldPrice = extItem.old_price ? parseFloat(extItem.old_price) : null;

    return {
      storeId,
      itemId,
      price: currentPrice,
      onSale: extItem.other === 'SALE',
      ...(oldPrice !== null ? { salePrice: oldPrice } : {}),
      inStock: true,
      ...(extItem.aisle ? { aisle: extItem.aisle } : {}),
      lastUpdated: now,
    };
  }).filter(doc => doc.itemId);

  const inventoryByKey = new Map();
  for (const doc of inventoryDocs) {
    const key = `${doc.storeId.toString()}:${doc.itemId.toString()}`;
    if (!inventoryByKey.has(key)) {
      inventoryByKey.set(key, doc);
    }
  }
  const uniqueInventoryDocs = Array.from(inventoryByKey.values());

  await db.collection('storeInventory').deleteMany({});
  if (uniqueInventoryDocs.length > 0) {
    await db.collection('storeInventory').insertMany(uniqueInventoryDocs);
  }

  console.log(`Success! Seeded ${storeDocs.length} stores and ${uniqueItems.length} real items.`);
  await client.close();
}

seed().catch(console.error);
